#### uptime：CPU 平均负载

可以理解为是平均活跃进程数。这个数最好不要超过CPU数，超过了就会出现CPU竞争的问题。  

##### 平均负载分析：  
mpstat：CPU分析工具。  
pidstat：进程分析工具（查看CPU、内存、磁盘io）。

##### CPU负载高的可能性：  
CPU密集型：1、CPU被进程耗尽；2、进程太多，互相竞争，等待CPU。  
磁盘io型：磁盘读写导致CPU空闲等待中。


---
#### CPU 上下文切换
CPU上下文：包含CPU寄存器 和 程序计数器。  
CPU寄存器：CPU内存。  
程序计数器：用来存储CPU正在执行的指令位置，或者即将执行的下一条指令位置。

CPU上下文切换分为：
```
进程上下文切换
线程上下文切换
中断上下文切换。
```
##### 进程上下文切换：
进程运行空间分为内核空间（ring0）和用户空间(ring3)。  

进程上下文切换:
```
1、是指从一个进程切换到另一个进程运行。
2、进程的上下文包括了虚拟内存、栈、全局变量等用户空间资源，还包括内核堆栈、CPU寄存器等内核空间的状态。
3、这个过程都需要消耗CPU来完成，大概需要几十纳秒到几微秒的时间，上下文切换的越多，消耗的时间就越多，真正运行进程的时间就越少。
```
进程切换场景：  
```
1、CPU时间片公平调度。
2、进程所需资源不足（内存等），会发生挂起切换。
3、sleep 等函数，也会将自己挂起切换。
4、有更高优先级的进程进来。
5、发生硬件中断，会挂起进程，去执行内核中的中断服务。
```
线程上下文切换：
```
1、不同进程的线程上下文切换，跟进程上下文切换一样。
2、相同进程的线程上下文切换，虚拟内存、全局变量等资源不变，只切换私有数据、寄存器等不共享的数据。
3、总结：这是多线程代替多进程的一个优势。
```
中断上下文切换：
```
1、发生硬件中断时，会立刻打断进程的正常执行，转而去处理内核的中断服务。但不影响用户态的数据。
2、中断上下文切换只包括内核态中断服务所需要的状态（CPU寄存器、内核堆栈、硬件中断参数）
3、中断处理比进程拥有更高的优先级。
```
##### 总结：
过多的CPU上下文切换，会把CPU时间消耗在寄存器、内核堆栈以及虚拟内存等数据的保存及恢复上，从而缩短进程真正运行的时间，导致系统性能下降。

##### 分析CPU上下文切换：
```
vmstat：可用来分析CPU上下文切换和中断的次数。

# 每两秒输出一组数据
# vmstat 2
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 4  0      0 2610408   2088 3135552    0    0     5     7    0    0  3  7 89  0  0
 2  0      0 2610432   2088 3135584    0    0     0     0 2475  426 16 34 50  0  0
 2  0      0 2610432   2088 3135584    0    0     0     0 2529  478 16 35 50  0  0
 3  0      0 2610432   2088 3135584    0    0     0   132 2530  463 16 35 50  0  0

注解：
cs（context switch）是每秒上下文切换的次数。
in（interrupt）则是每秒中断的次数。
r（Running or Runnable）是就绪队列的长度，也就是正在运行和等待 CPU 的进程数。
b（Blocked）则是处于不可中断睡眠状态的进程数。
```
```
pidstat 进程中断查看工具。
-t 查看子线程。
# 每两秒输出一组数据
# pidstat -wt 2
05:17:48 PM   UID       PID   cswch/s nvcswch/s  Command
05:17:50 PM     0         1      0.50      0.00  systemd
05:17:50 PM     0         3      0.50      0.00  ksoftirqd/0
05:17:50 PM     0         9     65.50      0.00  rcu_sched
05:17:50 PM     0        11      0.50      0.00  watchdog/0
05:17:50 PM     0        12      0.50      0.00  watchdog/1
05:17:50 PM     0        14      1.00      0.00  ksoftirqd/1
05:17:50 PM     0        17      0.50      0.00  watchdog/2
05:17:50 PM     0        22      0.50      0.00  watchdog/3
05:17:50 PM     0       289     20.00      0.00  xfsaild/vda1

注解：
cswch  ，表示每秒自愿上下文切换（voluntary context switches）的次数。
nvcswch  ，表示每秒非自愿上下文切换（non voluntary context switches）的次数。

自愿上下文切换，是指进程无法获取所需资源，导致的上下文切换。比如说， I/O、内存等系统资源不足时，就会发生自愿上下文切换。
非自愿上下文切换，则是指进程由于时间片已到等原因，被系统强制调度，进而发生的上下文切换。比如说，大量进程都在争抢 CPU 时，就容易发生非自愿上下文切换。
```
##### 总结：
```
1、自愿上下文切换变多了，说明进程都在等待资源，有可能发生了 I/O 等其他问题；
2、非自愿上下文切换变多了，说明进程都在被强制调度，也就是都在争抢 CPU，说明 CPU 的确成了瓶颈；
3、中断次数变多了，说明 CPU 被中断处理程序占用，还需要通过查看 /proc/interrupts 文件来分析具体的中断类型。
4、查看中断次数，分析哪个类型最多：watch -d 'cat /proc/interrupts'
```

---
#### Linux 软中断
```
1、上半部直接处理硬件请求，叫硬中断，会直接打断CPU正在执行的任务，立即执行中断处理程序。(/proc/interrupts)
2、下半部则是由内核触发，叫软中断，由硬中断通知执行，延迟执行。包括网络收发、定时、调度、RCU锁等。(/proc/softirqs)
```
